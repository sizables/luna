{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/lune/index.js","node_modules/lune/lib/lune.js","src/luna.coffee"],"names":[],"mappings":"AAAA;ACAA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrcA,IAAA;;AAAA,IAAA,GAAO,MAAM,CAAC,IAAP,GAAc,OAAA,CAAQ,MAAR;;AACrB,MAAM,CAAC,MAAP,GAAgB,SAAA;SACd,OAAO,CAAC,GAAR,CAAY,IAAI,CAAC,KAAL,CAAA,CAAZ;AADc","file":"luna.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = require('./lib/lune.js');\n","/**\n * This library calculates the current phase of the moon\n * as well as finds the dates of the recent moon phases.\n *\n * Ported from python version found here:\n * https://bazaar.launchpad.net/~keturn/py-moon-phase/trunk/annotate/head:/moon.py\n *\n * Author: Ryan Seys (https://github.com/ryanseys)\n */\n\n(function() {\n  // Phases of the moon & precision\n\n  var PRECISION = 0.05;\n  var NEW = 0 / 4.0;\n  var FIRST = 1 / 4.0;\n  var FULL = 2 / 4.0;\n  var LAST = 3 / 4.0;\n  var NEXTNEW = 4 / 4.0;\n\n  /**\n   * Gets the Julian value from a date object.\n   * Source: http://javascript.about.com/library/bljulday.htm\n   * @return {Number} Julian number representation of the date.\n   */\n  Date.prototype.getJulian = function() {\n    return (this.valueOf() / 86400000) - (this.getTimezoneOffset() / 1440) + 2440587.5;\n  };\n\n  /**\n   * Converts a Number in Julian date form to a Date object.\n   * Source: http://blog.bahrenburgs.com/2011/01/javascript-julian-day-conversions.html\n   */\n  Number.prototype.Julian2Date = function(inUTC) {\n    var X = parseFloat(this)+0.5;\n    var Z = Math.floor(X); //Get day without time\n    var F = X - Z; //Get time\n    var Y = Math.floor((Z-1867216.25)/36524.25);\n    var A = Z+1+Y-Math.floor(Y/4);\n    var B = A+1524;\n    var C = Math.floor((B-122.1)/365.25);\n    var D = Math.floor(365.25*C);\n    var G = Math.floor((B-D)/30.6001);\n    //must get number less than or equal to 12)\n    var month = (G<13.5) ? (G-1) : (G-13);\n    //if Month is January or February, or the rest of year\n    var year = (month<2.5) ? (C-4715) : (C-4716);\n    month -= 1; //Handle JavaScript month format\n    var UT = B-D-Math.floor(30.6001*G)+F;\n    var day = Math.floor(UT);\n    //Determine time\n    UT -= Math.floor(UT);\n    UT *= 24;\n    var hour = Math.floor(UT);\n    UT -= Math.floor(UT);\n    UT *= 60;\n    var minute = Math.floor(UT);\n    UT -= Math.floor(UT);\n    UT *= 60;\n    var second = Math.round(UT);\n\n    if (inUTC) {\n      return new Date(Date.UTC(year, month, day, hour, minute, second));\n    } else {\n      return new Date(year, month, day, hour, minute, second);\n    }\n  };\n\n  /**\n   * Astronomical Constants\n   * @type {Object}\n   */\n  const c = {\n    // JDN stands for Julian Day Number\n    // Angles here are in degrees\n\n    // 1980 January 0.0 in JDN\n    // XXX: DateTime(1980).jdn yields 2444239.5 -- which one is right?\n    epoch: 2444238.5,\n\n    // Ecliptic longitude of the Sun at epoch 1980.0\n    ecliptic_longitude_epoch: 278.833540,\n\n    // Ecliptic longitude of the Sun at perigee\n    ecliptic_longitude_perigee: 282.596403,\n\n    // Eccentricity of Earth's orbit\n    eccentricity: 0.016718,\n\n    // Semi-major axis of Earth's orbit, in kilometers\n    sun_smaxis: 1.49585e8,\n\n    // Sun's angular size, in degrees, at semi-major axis distance\n    sun_angular_size_smaxis: 0.533128,\n\n    // Elements of the Moon's orbit, epoch 1980.0\n\n    // Moon's mean longitude at the epoch\n    moon_mean_longitude_epoch: 64.975464,\n    // Mean longitude of the perigee at the epoch\n    moon_mean_perigee_epoch: 349.383063,\n\n    // Mean longitude of the node at the epoch\n    node_mean_longitude_epoch: 151.950429,\n\n    // Inclination of the Moon's orbit\n    moon_inclination: 5.145396,\n\n    // Eccentricity of the Moon's orbit\n    moon_eccentricity: 0.054900,\n\n    // Moon's angular size at distance a from Earth\n    moon_angular_size: 0.5181,\n\n    // Semi-mojor axis of the Moon's orbit, in kilometers\n    moon_smaxis: 384401.0,\n    // Parallax at a distance a from Earth\n    moon_parallax: 0.9507,\n\n    // Synodic month (new Moon to new Moon), in days\n    synodic_month: 29.53058868,\n\n    // Base date for E. W. Brown's numbered series of lunations (1923 January 16)\n    lunations_base: 2423436.0,\n\n    // #Properties of the Earth\n    earth_radius: 6378.16\n  };\n\n  function fixangle(a) {\n    return a - 360.0 * Math.floor(a/360.0);\n  }\n\n  /**\n   * Convert degrees to radians\n   * @param  {Number} d Angle in degrees\n   * @return {Number}   Angle in radians\n   */\n  function torad(d) {\n    return d * Math.PI / 180.0;\n  }\n\n  /**\n   * Convert radians to degrees\n   * @param  {Number} r Angle in radians\n   * @return {Number}   Angle in degrees\n   */\n  function todeg(r) {\n    return r * 180.0 / Math.PI;\n  }\n\n  function dsin(d) {\n    return Math.sin(torad(d));\n  }\n\n  function dcos(d) {\n    return Math.cos(torad(d));\n  }\n\n  /**\n   * Solve the equation of Kepler.\n   */\n  function kepler(m, ecc) {\n    var epsilon = 1e-6;\n\n    m = torad(m);\n    var e = m;\n    while(1) {\n      var delta = e - ecc * Math.sin(e) - m;\n      e = e - delta / (1.0 - ecc * Math.cos(e));\n\n      if (Math.abs(delta) <= epsilon) {\n        break;\n      }\n    }\n\n    return e;\n  }\n\n  /**\n   * Finds the phase information for specific date.\n   * @param  {Date} phase_date Date to get phase information of.\n   * @return {Object}          Phase data\n   */\n  function phase(phase_date) {\n    if(!phase_date) {\n      phase_date = (new Date()).getJulian();\n    }\n    else {\n      phase_date = phase_date.getJulian();\n    }\n\n    var day = phase_date - c.epoch;\n\n    // Mean anomaly of the Sun\n    var N = fixangle((360/365.2422) * day);\n    //Convert from perigee coordinates to epoch 1980\n    var M = fixangle(N + c.ecliptic_longitude_epoch - c.ecliptic_longitude_perigee);\n\n    // Solve Kepler's equation\n    var Ec = kepler(M, c.eccentricity);\n    Ec = Math.sqrt((1 + c.eccentricity) / (1 - c.eccentricity)) * Math.tan(Ec/2.0);\n    // True anomaly\n    Ec = 2 * todeg(Math.atan(Ec));\n    // Suns's geometric ecliptic longuitude\n    var lambda_sun = fixangle(Ec + c.ecliptic_longitude_perigee);\n\n    // Orbital distance factor\n    var F = ((1 + c.eccentricity * Math.cos(torad(Ec))) / (1 - Math.pow(c.eccentricity, 2)));\n\n    // Distance to Sun in km\n    var sun_dist = c.sun_smaxis / F;\n    var sun_angular_diameter = F * c.sun_angular_size_smaxis;\n\n    // Calculation of the Moon's position\n\n    // Moon's mean longitude\n    var moon_longitude = fixangle(13.1763966 * day + c.moon_mean_longitude_epoch);\n\n    // Moon's mean anomaly\n    var MM = fixangle(moon_longitude - 0.1114041 * day - c.moon_mean_perigee_epoch);\n\n    // Moon's ascending node mean longitude\n    // MN = fixangle(c.node_mean_longitude_epoch - 0.0529539 * day)\n\n    var evection = 1.2739 * Math.sin(torad(2*(moon_longitude - lambda_sun) - MM));\n\n    // Annual equation\n    var annual_eq = 0.1858 * Math.sin(torad(M));\n\n    // Correction term\n    var A3 = 0.37 * Math.sin(torad(M));\n\n    var MmP = MM + evection - annual_eq - A3;\n\n    // Correction for the equation of the centre\n    var mEc = 6.2886 * Math.sin(torad(MmP));\n\n    // Another correction term\n    var A4 = 0.214 * Math.sin(torad(2 * MmP));\n\n    // Corrected longitude\n    var lP = moon_longitude + evection + mEc - annual_eq + A4;\n\n    // Variation\n    var variation = 0.6583 * Math.sin(torad(2*(lP - lambda_sun)));\n\n    // True longitude\n    var lPP = lP + variation;\n\n    // Calculation of the phase of the Moon\n\n    // Age of the Moon, in degrees\n    var moon_age = lPP - lambda_sun;\n\n    // Phase of the Moon\n    var moon_phase = (1 - Math.cos(torad(moon_age))) / 2.0;\n\n    // Calculate distance of Moon from the centre of the Earth\n    var moon_dist = (c.moon_smaxis * (1 - Math.pow(c.moon_eccentricity,2))) / (1 + c.moon_eccentricity * Math.cos(torad(MmP + mEc)));\n\n    // Calculate Moon's angular diameter\n    var moon_diam_frac = moon_dist / c.moon_smaxis;\n    var moon_angular_diameter = c.moon_angular_size / moon_diam_frac;\n\n    // Calculate Moon's parallax (unused?)\n    // moon_parallax = c.moon_parallax / moon_diam_frac\n\n    var res = {\n      'phase': fixangle(moon_age) / 360.0,\n      'illuminated': moon_phase,\n      'age': c.synodic_month * fixangle(moon_age) / 360.0,\n      'distance': moon_dist,\n      'angular_diameter': moon_angular_diameter,\n      'sun_distance': sun_dist,\n      'sun_angular_diameter': sun_angular_diameter\n    };\n\n    return res;\n  }\n\n  /**\n   * Find time of phases of the moon which surround the current date.\n   * Five phases are found, starting and ending with the new moons\n   * which bound the current lunation.\n   * @param  {Date} sdate Date to start hunting from (defaults to current date)\n   * @return {Object}     Object containing recent past and future phases\n   */\n  function phase_hunt(sdate) {\n    if(!sdate) {\n      sdate = new Date();\n    }\n\n    var adate = new Date(sdate.valueOf()); // today!\n    var x = 45; // go back 45 days!\n    adate.setDate(adate.getDate() - x);\n\n    var k1 = Math.floor((adate.getFullYear() + ((adate.getMonth()) * (1.0/12.0)) - 1900) * 12.3685);\n    var nt1 = meanphase(adate, k1);\n    adate = nt1;\n\n    sdate = sdate.getJulian();\n    var k2;\n    while(1) {\n      adate = adate + c.synodic_month;\n      k2 = k1 + 1;\n      var nt2 = meanphase(adate, k2);\n      if(nt1 <= sdate && sdate < nt2) {\n        break;\n      }\n      nt1 = nt2;\n      k1 = k2;\n    }\n    var ks = [k1, k1, k1, k1, k2];\n    var tphases = [NEW, FIRST, FULL, LAST, NEW];\n    var phase_names = ['new_date', 'q1_date', 'full_date', 'q3_date', 'nextnew_date'];\n    var phases = {};\n\n    for (var i = 0; i < ks.length; i++) {\n      phases[phase_names[i]] = truephase(ks[i], tphases[i]);\n    }\n\n    return phases;\n  }\n\n  /**\n   * Given a K value used to determine the mean phase of the new\n   * moon, and a phase selector (0.0, 0.25, 0.5, 0.75), obtain the\n   * true, corrected phase time.\n   * @param  {[type]} k      [description]\n   * @param  {[type]} tphase [description]\n   * @return {[type]}        [description]\n   */\n  function truephase(k, tphase) {\n\n    var apcor = false;\n\n    // add phase to new moon time\n    k = k + tphase;\n    // Time in Julian centuries from 1900 January 0.5\n    var t = k / 1236.85;\n\n    var t2 = t * t;\n    var t3 = t2 * t;\n\n    // Mean time of phase\n    var pt = (\n      2415020.75933 + c.synodic_month * k + 0.0001178 * t2 -\n      0.000000155 * t3 + 0.00033 * dsin(166.56 + 132.87 * t -\n      0.009173 * t2)\n    );\n\n    // Sun's mean anomaly\n    var m = 359.2242 + 29.10535608 * k - 0.0000333 * t2 - 0.00000347 * t3;\n\n    // Moon's mean anomaly\n    var mprime = 306.0253 + 385.81691806 * k + 0.0107306 * t2 + 0.00001236 * t3;\n\n    // Moon's argument of latitude\n    var f = 21.2964 + 390.67050646 * k - 0.0016528 * t2 - 0.00000239 * t3;\n\n    if ((tphase < 0.01) || (Math.abs(tphase - 0.5) < 0.01)) {\n\n      // Corrections for New and Full Moon\n      pt = pt + (\n        (0.1734 - 0.000393 * t) * dsin(m) +\n        0.0021 * dsin(2 * m) -\n        0.4068 * dsin(mprime) +\n        0.0161 * dsin(2 * mprime) -\n        0.0004 * dsin(3 * mprime) +\n        0.0104 * dsin(2 * f) -\n        0.0051 * dsin(m + mprime) -\n        0.0074 * dsin(m - mprime) +\n        0.0004 * dsin(2 * f + m) -\n        0.0004 * dsin(2 * f - m) -\n        0.0006 * dsin(2 * f + mprime) +\n        0.0010 * dsin(2 * f - mprime) +\n        0.0005 * dsin(m + 2 * mprime)\n      );\n\n      apcor = true;\n    }\n    else if ((Math.abs(tphase - 0.25) < 0.01) || (Math.abs(tphase - 0.75) < 0.01)) {\n        pt = pt + (\n          (0.1721 - 0.0004 * t) * dsin(m) +\n          0.0021 * dsin(2 * m) -\n          0.6280 * dsin(mprime) +\n          0.0089 * dsin(2 * mprime) -\n          0.0004 * dsin(3 * mprime) +\n          0.0079 * dsin(2 * f) -\n          0.0119 * dsin(m + mprime) -\n          0.0047 * dsin(m - mprime) +\n          0.0003 * dsin(2 * f + m) -\n          0.0004 * dsin(2 * f - m) -\n          0.0006 * dsin(2 * f + mprime) +\n          0.0021 * dsin(2 * f - mprime) +\n          0.0003 * dsin(m + 2 * mprime) +\n          0.0004 * dsin(m - 2 * mprime) -\n          0.0003 * dsin(2 * m + mprime)\n        );\n      if (tphase < 0.5) {\n          //  First quarter correction\n          pt = pt + 0.0028 - 0.0004 * dcos(m) + 0.0003 * dcos(mprime);\n      }\n      else {\n          //  Last quarter correction\n          pt = pt + -0.0028 + 0.0004 * dcos(m) - 0.0003 * dcos(mprime);\n      }\n      apcor = true;\n    }\n\n    if (!apcor) {\n      console.log(\"TRUEPHASE called with invalid phase selector \", tphase);\n    }\n\n    return pt.Julian2Date(true);\n  }\n\n  /**\n   * Calculates time of the mean new Moon for a given base date.\n   * This argument K to this function is the precomputed synodic month\n   * index, given by:\n   *   K = (year - 1900) * 12.3685\n   * where year is expressed as a year and fractional year.\n   * @param  {Date} sdate   Start date\n   * @param  {[type]} k     [description]\n   * @return {[type]}       [description]\n   */\n  function meanphase(sdate, k) {\n\n    // Time in Julian centuries from 1900 January 12 noon\n    var delta_t = (sdate - (new Date(1900,0,1,12))) / (1000*60*60*24);\n    var t = delta_t / 36525;\n\n    // square for frequent use\n    var t2 = t * t;\n    // and cube\n    var t3 = t2 * t;\n\n    nt1 = (\n      2415020.75933 + c.synodic_month * k + 0.0001178 * t2 -\n      0.000000155 * t3 + 0.00033 * dsin(166.56 + 132.87 * t -\n      0.009173 * t2)\n    );\n\n    return nt1;\n  }\n\n  module.exports = {\n   'phase_hunt': phase_hunt,\n   'phase': phase\n  };\n})();\n","lune = window.lune = require 'lune'\nwindow.onload = ->\n  console.log lune.phase()\n\n# Phaser = require 'phaser'\n# window.onload = ->\n#   game = new Phaser.Game 800, 600, Phaser.AUTO, '', {\n#     preload: ->\n#       game.load.image 'logo', 'luna.png'\n#     create: ->\n#       logo = game.add.sprite game.world.centerX, game.world.centerY, 'logo'\n#       logo.anchor.setTo 0.5, 0.5\n#   }\n"]}